{
  "name": "fluid",
  "version": "0.1.3",
  "description": "Create fluent interfaces, inline, around any object, allowing simple chained async method calls.",
  "author": {
    "name": "Pete Clark",
    "email": "pclarkgithub@gmail.com"
  },
  "contributors": [],
  "dependencies": {
    "async": "= 0.1.22"
  },
  "devDependencies": {
    "vows": "= 0.6.3"
  },
  "main": "./lib/fluid.js",
  "scripts": {
    "test": "vows --spec"
  },
  "keywords": [
    "fluent",
    "fluid",
    "async",
    "flow",
    "control",
    "chaining",
    "chained"
  ],
  "repository": {
    "type": "git",
    "url": "git://github.com/peteclark82/node-fluid"
  },
  "bugs": {
    "url": "https://github.com/peteclark82/node-fluid/issues"
  },
  "licenses": [
    {
      "type": "MIT",
      "url": "https://github.com/peteclark82/node-fluid/LICENSE"
    }
  ],
  "readme": "# Fluid.js [![Build Status](https://secure.travis-ci.org/peteclark82/node-fluid.png)](https://secure.travis-ci.org/peteclark82/node-fluid.png)\r\n\r\nFluid.js is a simple fluent interface API for javascript and node.js. It is used to create fluent interfaces\r\naround existing vanilla objects, without all the boiler plate code.\r\n\r\nThis is a useful extension to the popular [Async](https://github.com/caolan/async) module.\r\n\r\nNOTE: Fluid.js currently only supports methods that take a callback as the last argument:-\r\n\r\n\tfunction(options, callback) -> callback(err, result)\r\n\t\t\r\n\tfunction(arg1, arg2, ..., callback) -> callback(err, result)\r\n\t\r\n\tetc...\r\n\r\n\r\n## The Problem\r\n\r\nFlow control and callbacks can become very messy and unmanagable when using lots of asynchronous functions.\r\nMany libraries exist for node.js that make things much less painful. This module is meant to add yet another\r\ntool to your belt.\r\n\r\nFor example a typical bit of file processing might look something like:-\r\n\r\n\tfs.readFile(\"./input1.txt\", function(err, input1Buffer) {\r\n\t\tif (err) {console.log(err)} else {\r\n\t\t\tfs.readFile(\"./input2.txt\", function(err, input2Buffer) {\r\n\t\t\t\tif (err) {console.log(err)} else {\r\n\t\t\t\t\tvar content = input1Buffer.toString() + input2Buffer.toString();\r\n\t\t\t\t\tfs.writeFile(\"./output.txt\", content, function(err) {\r\n\t\t\t\t\t\tif (err) {console.log(err)} else {\r\n\t\t\t\t\t\t\t//do something\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\t});\r\n\r\nWith Fluid.js we could write it like this:-\r\n\t\r\n\t$f(fs).readFile(\"./input1.txt\").readFile(\"./input2.txt\")\r\n\t\t.writeFile(\"./output1.txt\", $f(\"this.readFile[0].toString() + this.readFile[1].toString()\"))\r\n\t.go(function(err, values) {\r\n\t\tif (err) {console.log(err)} else {\r\n\t\t\t//do something\r\n\t\t}\r\n\t});\r\n\t\r\nAny error handling is managed in the \"go\" callback and all callback return values are available for usage.\r\n\r\n\t\r\n## Quick Examples\r\n\r\n### Setup\r\n\r\n\tvar $f = require(\"fluid\");\r\n\r\n### Example Objects\r\n\t\r\n\tvar myFirstObj = {\r\n\t\tdoSomething : function(options, callback) { \r\n\t\t\t//do something\r\n\t\t\tcallback(err, result);\r\n\t\t},\r\n\t\tdoSomethingElse : function(options, callback) {\r\n\t\t\t//do something else\r\n\t\t\tcallback(err, result);\r\n\t\t}\r\n\t};\r\n\t\r\n\tvar mySecondObj = {\r\n\t\tdoSomethingMore : function(options, callback) {\r\n\t\t\t//do something more\r\n\t\t\tcallback(err, result);\r\n\t\t}\r\n\t};\r\n\t\r\n### Streamlined\r\n\r\nNote: series is the default flow control mode, so it can be ommitted\r\n\t\r\n\t$f(myFirstObj).doSomething(/* args */).doSomethingElse(/* args */)\r\n\t\t.with(mySecondObj).doSomethingMore(/* args */)\r\n\t.go(function(err, results) {\r\n\t\t// results is now an array of return values from each method callback\r\n\t});\r\n\r\n### Expressive\r\n\t\r\n\t$f().series()\t\t\r\n\t\t.with(myFirstObj)\r\n\t\t\t.doSomething(/* args */)\r\n\t\t\t.doSomethingElse(/* args */)\r\n\t\t.with(mySecondObj)\r\n\t\t\t.doSomethingMore(/* args */)\r\n\t.go(function(err, results) {\r\n\t\t// results is now an array of return values from each method callback\r\n\t});\t\r\n\r\n### Multiple flow control types\r\n\t\r\n\t$f()\r\n\t\t.series()\t\t\r\n\t\t\t.with(myFirstObj)\r\n\t\t\t\t.doSomething(/* args */)\r\n\t\t\t\t.doSomethingElse(/* args */)\r\n\t\t.parallel()\t\t\r\n\t\t\t.with(mySecondObj)\r\n\t\t\t\t.doSomethingMore(/* args */)\r\n\t\t\t\t.doSomethingMorer(/* args */)\r\n\t\t\t\t.doSomethingMorerer(/* args */)\r\n\t.go(function(err, results) {\r\n\t\t// results is now an array of return values from each method callback\r\n\t});\r\n\t\r\n\r\n## Install\r\n\r\nTo install with node package manager:\r\n\r\n\tnpm install fluid\r\n\t\t\r\n\t\t\r\n## Test\r\n\r\nTo test with node package manager:\r\n\t\r\n\tnpm test\r\n\r\n\t\r\n## Download\r\n\r\nReleases are available for download from\r\n[GitHub](https://github.com/peteclark82/node-fluid).\r\n\r\n\r\n## Documentation\r\n\r\n* [fluid](#fluid)\r\n\r\n### Fluid Context Methods\r\n\r\n* [with](#with)\r\n* [series](#series)\r\n* [parallel](#parallel)\r\n* [info](#info)\r\n* [custom](#custom)\r\n* [self](#self)\r\n* [go](#go)\r\n* [context methods](#contextMethods)\r\n* [late bound arguments](#lateBoundArgs)\r\n\r\n---------------------------------------\r\n\r\n<a name=\"fluid\" />\r\n### fluid([context])\r\n\r\nCreates a new fluent interface (fluid context), optionally wrapping an initial user \r\nspecifed application context.\r\n\r\nNote, if desired, the initial context can be left blank and applied later using the [with](#with) \r\ncommand.\r\n\r\n__Arguments__\r\n\r\n* context - An initial application context to wrap with fluent methods.\r\n* Returns a new fluid context.\r\n  \r\n__Example__\r\n\r\n\t$f(fs).readFile(\"./test.txt\")  \r\n\t\t/* .etc.etc... */\r\n\t.go(function(err, res) { /* finished */ }\r\n\r\n\r\n---------------------------------------\r\n### Fluid Context Methods\r\n---------------------------------------\t\t\r\n\r\n\r\n<a name=\"with\" />\r\n### with(context)\r\n\r\nSwitches the current application context to the one specified.\r\n\r\nNote, The context can be switch as many times as required. Useful when working \r\nwith multiple libraries.\r\n\r\n__Arguments__\r\n\r\n* context - An application context to wrap.\r\n* Returns the current fluid context.\r\n  \r\n__Example__\r\n\r\n\t$f(myObj).doSomething(/* args */)\r\n\t\t.with(myObj2).doSomethingElse(/* args */) \r\n\t\t/* .etc.etc... */\r\n\t.go(function(err, res) { /* finished */ });\r\n\r\n\r\n---------------------------------------\r\n\r\n<a name=\"series\" />\r\n### series()\r\n\r\nCreates a new group of method calls that will be executed in series. Multiple groups \r\nwith different flow control types can be used together, and will themselves be executed in series when the \r\n[go](#go) command is called.\r\n\r\nNote, This is the default execution mode when a new fluid context has been created.\r\n\r\n__Arguments__\r\n\r\n* Returns the current fluid context.\r\n  \r\n__Example__\r\n\r\n\t$f(myObj).series()\r\n\t\t.doSomething(/* args */)\r\n\t\t.doSomethingElse(/* args */)\r\n\t\t/* .etc.etc... */\r\n\t.go(function(err, res) { /* finished */ });\r\n\t\t\r\n\t\t\r\n---------------------------------------\r\n\r\n<a name=\"parallel\" />\r\n### parallel()\r\n\r\nCreates a new group of method calls that will be executed in parallel. Multiple groups \r\nwith different flow control types can be used together, and will themselves be executed in series when the \r\n[go](#go) command is called.\r\n\r\nNote, see the [Async](https://github.com/caolan/async) module for more information on the difference \r\nbetween series and parallel flow controls.\r\n\r\n__Arguments__\r\n\r\n* Returns the current fluid context.\r\n  \r\n__Example__\r\n\r\n\t$f(myObj).parallel()\r\n\t\t.doSomething(/* args */)\r\n\t\t.doSomethingElse(/* args */)\r\n\t\t/* .etc.etc... */\r\n\t.go(function(err, res) { /* finished */ });\r\n\r\n\r\n---------------------------------------\r\n\r\n<a name=\"info\" />\r\n### info(options)\r\n\r\nProvides a way to explicitly name callback values on the result. Also allows decorating errors with extra detail.\r\n\r\n__Arguments__\r\n\r\n* options - Options for providing explicit detail for result\r\n    * name - String. Specifies a name for the callback return value on the result.\r\n\t* error - String. Specifies extra detail to decorate any error raised.\r\n  \r\n__Example__\r\n\r\n\t$f(fs)\r\n\t\t.info({name : \"test1\"}).readFile(\"./test1.txt\")\r\n\t\t.info({name : \"test2\"}).readFile(\"./test2.txt\")\r\n\t.go(function(err, result) {\r\n\t\t/*\r\n\t\t\tresult:-\r\n\t\t\t{\r\n\t\t\t\ttest1 : [<Buffer>],\r\n\t\t\t\ttest2 : [<Buffer>]\r\n\t\t\t}\r\n\t\t*/\t\t\r\n\t});\r\n\r\nYou can also use the short hand:-\r\n\r\n\t$f(fs)\r\n\t\t({name : \"test1\"}).readFile(\"./test1.txt\")\r\n\t\t({name : \"test2\"}).readFile(\"./test2.txt\")\r\n\t.go(function(err, result) {});\r\n\t\r\nNote, there is no '.' before the '('. The fluid context itself wraps the info function.\r\n\r\n\t\r\n---------------------------------------\r\n\r\n<a name=\"custom\" />\r\n### custom(customFunction(callback))\r\n\r\nCreates a new custom task that is added to the existing group. The custom task must invoke the callback provided \r\nwhen finished processing.\r\n\r\n__Arguments__\r\n\r\n* customFunction(callback) - Some custom code that will receive a callback to be invoked upon completion. \r\n    * callback - Function. A callback to invoke when custom code has completed.\r\n\r\n__Example__\r\n\r\n\t$f(fs)\r\n\t\t.readFile(\"./test1.txt\")\r\n\t\t.readFile(\"./test2.txt\")\r\n\t\t.custom(function(callback) {\r\n\t\t\tcallback(null, this.readFile[0].toString() + this.readFile[1].toString());\r\n\t\t})\r\n\t\t.writeFile(\"./output.txt\", $f(\"this.custom[0]\"))\r\n\t.go(function(err, result) {});\r\n\r\n\r\n---------------------------------------\r\n\r\n<a name=\"self\" />\r\n### self()\r\n\r\nIf the context being wrapped is a function itself, it can be invoked using the self method.\r\n\r\n__Example__\r\n\t\r\n\tvar myFunc = function(arg, callback) { \r\n\t\tcallback(null, arg + 1);\r\n\t}\r\n\r\n\t$f(myFunc)\r\n\t\t.self(1)\r\n\t\t.self(2)\r\n\t.go(function(err, result) {});\r\n\r\n\t\t\r\n---------------------------------------\r\n\r\n<a name=\"go\" />\r\n### go([options,] callback)\r\n\r\nExecutes all queued function calls against their registered application contexts, then invokes the specified\r\ncallback when completed, or any of the methods error.\r\n\r\nIf multiple flow control groups have been created, each group will be executed in series.\r\n\r\n__Arguments__\r\n\r\n* Optional. options - Options for execution\r\n    * debug - Boolean. Logs out to the console information about execution for debugging.\r\n* callback(err, result) - A callback that is invoked after all of the methods have been executed,\r\n  or an error occurrs. If no error occurrs, result will be an object containing arrays of values from each function callback.\r\n  \r\n__Example__\r\n\r\n    // assuming an object exists called myObj\t\r\n\t$f(myObj).series()\r\n\t\t.doSomething(/* args */)\r\n\t\t.doSomething(/* args */)\r\n\t\t.doSomethingElse(/* args */)\r\n\t.parallel()\r\n\t\t.doSomethingMore(/* args */)\r\n\t.go(function(err, result) { \r\n\t\tif (err) { /* error */ } else {\r\n\t\t/* \r\n\t\t\tresult :-\t\t\t\t\r\n\t\t\t{\r\n\t\t\t\t\"doSomething\" : [\r\n\t\t\t\t\t{ /* return value from first doSomething */ }\r\n\t\t\t\t\t{ /* return value from second doSomething */ }\r\n\t\t\t\t],\r\n\t\t\t\t\"doSomethingElse\" : [{ /* return value from doSomethingElse */ }],\r\n\t\t\t\t\"doSomethingMore\" : [{ /* return value from doSomethingMore */ }]\r\n\t\t\t}\r\n\t\t*/\r\n\t\t}\r\n\t});\r\n\r\n\r\n---------------------------------------\r\n\r\n<a name=\"contextMethods\" />\r\n### Context Methods\r\n\r\nThe fluid context will wrap all function properties of an object.\r\n\r\nNOTE: Fluid.js currently only supports methods that take a callback as the last argument:-\r\n\r\n\tfunction(options, callback) -> callback(err, result)\r\n\t\t\r\n\tfunction(arg1, arg2, ..., callback) -> callback(err, result)\r\n\t\r\n\tetc...\r\n\r\n\r\n__Example__\r\n\r\n    var myCalculator = {\r\n\t\taddTen : function(val, callback) {\r\n\t\t\tcallback(null, val + 10 );\r\n\t\t},\r\n\t\tmultiplyByTen : function(val, callback) {\r\n\t\t\tcallback(null, val * 10);\r\n\t\t}\r\n\t};\r\n\t\t\r\n\t$f(myCalculator)\r\n\t\t.addTen(1)\r\n\t\t.addTen(2)\r\n\t\t.multiplyByTen(2)\r\n\t.go(function(err, result) {\r\n\t\t/* \r\n\t\t\tresult :-\r\n\t\t\t{\r\n\t\t\t\t\"addTen\" : [11, 12],\r\n\t\t\t\t\"multiplyByTen\" : [20]\r\n\t\t\t}\t\t\r\n\t\t*/\r\n\t});\r\n\t\r\nYou can even use the result of previous callbacks in the arguments to other functions. See [late bound arguments](#lateBoundArgs).\r\n\t\r\n\t$f(myCalculator)\r\n\t\t.addTen(1)\r\n\t\t.multiplyByTen($f(\"this.addTen[0]\"))\r\n\t.go(function(err, result) {\r\n\t\t/* \r\n\t\t\tresult :-\r\n\t\t\t{\r\n\t\t\t\t\"addTen\" : [11],\r\n\t\t\t\t\"multiplyByTen\" : [110]\r\n\t\t\t}\t\t\r\n\t\t*/\r\n\t});\r\n\r\n\r\n---------------------------------------\r\n\r\n<a name=\"lateBoundArgs\" />\r\n### Late Bound Arguments - fluid(expression)\r\n\r\nLate bound arguments are useful when you need the result of a previous function as an argument to another.\r\n\r\n__Arguments__\r\n\r\n* expression - String. A javascript expression to be evaluated when the function is called.\r\n\t'this' is the current result so far, and will contain return values of all previously executed callbacks.\r\n\r\n__Example__\r\n\r\n\t$f(myCalculator)\r\n\t\t.addTen(1)\r\n\t\t.multiplyByTen($f(\"this.addTen[0]\"))\r\n\t.go(function(err, result) {\r\n\t\t/* \r\n\t\t\tresult :-\r\n\t\t\t{\r\n\t\t\t\t\"addTen\" : [11],\r\n\t\t\t\t\"multiplyByTen\" : [110]\r\n\t\t\t}\t\t\r\n\t\t*/\r\n\t});\r\n\t\r\nNote, Fluid treats all string passed to it as late bound argument expressions.\r\n\r\n\r\n---------------------------------------\r\n\r\n### License\r\n\r\nCopyright(c) 2012 Pete Clark\r\n\r\nMIT license\r\n\r\nPermission is hereby granted, free of charge, to any person\r\nobtaining a copy of this software and associated documentation\r\nfiles (the \"Software\"), to deal in the Software without\r\nrestriction, including without limitation the rights to use,\r\ncopy, modify, merge, publish, distribute, sublicense, and/or sell\r\ncopies of the Software, and to permit persons to whom the\r\nSoftware is furnished to do so, subject to the following\r\nconditions:\r\n\r\nThe above copyright notice and this permission notice shall be\r\nincluded in ALL copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\r\nOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\r\nHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\r\nWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\r\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\r\nOTHER DEALINGS IN THE SOFTWARE.\r\n",
  "_id": "fluid@0.1.3",
  "_from": "fluid@~0.1.3"
}
